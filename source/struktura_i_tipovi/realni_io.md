# Унос и приказ реалних бројева

Као и за целобројни и знаковни тип, за унос и приказ реалних бројева користићеш
функције форматираног улаза и излаза `scanf()` и `printf()`.

:::{admonition} Напомена
:class: warning

У [табели у прилогу](../prilozi/tipovi_podataka.md) можеш видети да се за сваки
реални тип података може користи час осам спецификатора, на пример за тип
`double` могу се користити: `%lf`, `%lF`, `%lg`, `%lG`, `%le`, `%lE`, `%la` и
`%lA`.

Разлика између спецификатора у којима се користе мала и велика слова је само у
излазу. Уколико је на излазу потребно исписати слово, спецификатори са малим
словима на излазу исписаће све малим словима (нпр. `inf`, `nan` и `e`), док ће
они са великим словима исписати све великим словима (нпр. `INF`, `NAN` и `E`).
Значи, разлике су само естетске, а не и сусштинске, па да на даље можеш
користити нпр. само спецификаторе са малим словима.

Спецификатори за рад са хексадекадним реалним бројевима за тип `float` (`%a` и
`%A`) и типове `double` и `long double` (`%la` и `%lA`) уведени су тек каснијим
**C99** стандардном и њих нећеш користити у овом курсу.

Сада се број спецификатора које требаш разматрати свео са осам на три, и то:
`%lf`, `%lg` и `%le`.
:::

## Форматирани излаз

За приказ реалних бројева такође важи општи облик функције `printf()`

```text
printf(format, lista_argumenata);
```

где `format` увек почиње знаком `%` и има општи облик:

```text
%[dodatne_opcije]simbol_konverzije
```

а додатне опције могу бити `parametri`, `širina`, `.preciznost` и `dužina`.

У лекцији о реалном типу научио си да се реални бројеви представљају као
бројеви са покретном тачком, и то на више начина. За испис бројева у
**децималној нотацији** користи се спецификатор конверзије `%f` ако је податак
дефинисан типом `float`, односно `%lf`, ако је дефинисан типом `double`.

Нека је задатак да напишеш програм у програмском језику C који ће на стандардни
излаз исписати вредност иницијализоване реалне константе `pi`, која је
иницијализована на следећи начин:

```c
const double pi = 3.14159265358979323846;
```

Једноставно решење овог задатка може да изгледа овако:

```c
#include <stdio.h>

int main(void)
{
    const double pi = 3.14159265358979323846;
    printf("%lf", pi);
}
```

На стандардном излазу исписаће се вредност константе `pi` као реалан број у
децималној нотацији, заокружен на шест децималних места:

```text
3.141593
```

Научио си да реални типови имају одређену прецизност, па ако желиш да прикажеш
више децимала константе `pi`, на пример десет, можеш да користиш додатну опцију
`.preciznost` у спецификатору конверзије:

```c
#include <stdio.h>

int main(void)
{
    const double pi = 3.14159265358979323846;
    printf("%.10lf", pi);
}
```

Сада ће се на стандардном излазу исписати вредност константе `pi` као реалан
број у децималној нотацији, заокружен на десет децималних места:

```text
3.1415926536
```

Води рачуна о томе да, иако у поступку иницијализације податку реалног типа
доделиш број са више значајних цифара него што је предвиђено, прецизност ће
остати не промењена. Ако би у претходном примеру покушао да испишеш свих
двадесет децимала констане `pi` наведених у иницијализацији, само ће се
првих петнаест исписати коректно, а остала места биће попуњена неким насумично
одабраним цифрама (3.141592653589793**11600**).

За испис бројева у **научној нотацији** користи се спецификатор конверзије `%e`
ако је податак дефинисан типом `float`, односно `%le`, ако је дефинисан типом
`double`. Реалан број у овој нотацији записује се навођењем мантису, слова `е`
које представља основу и експонента.

Нека је сада задатак да напишеш програм у програмском језику C који ће на
стандардни излаз исписати капацитивност кондензатора од $39nF$ u Faradima
($39nF=0.000000039F$)

```c
#include <stdio.h>

int main(void)
{
    double c = 0.000000039;
    printf("%le", c);
}
```

Резултат на стандардном излазу представља број у научној нотацији:

```text
3.900000e-08
```

У овом случају, свакако је лакше протумачити број $3.9\times{10^{-8}}$ него
бројати нуле у децималном запису $0.000000039$.

За испис бројева у **оптимизованој нотацији** користи се спецификатор
конверзије `%g` ако је податак дефинисан типом `float`, односно `%lg`, ако је
дефинисан типом `double`. Из реалног броја у овој нотацији бришу се непотребне
нуле.

Нека је сада задатак да напишеш програм у програмском језику C који ће у три
реда стандардног излаза исписати три резултата Николиних скокова у даљ који су
износили $4.85$, $5$ и $5.1$ метар.

```c
#include <stdio.h>

int main(void)
{
    double skok_1 = 4.85, skok_2 = 5.0, skok_3 =5.1;
    printf("%lg\n%lg\n%lg", skok_1, skok_2, skok_3);
}
```

Бројеви на стандардном излазу записани су у оптималној нотацији:

```text
4.85
5
5.1
```

У децималној нотацији, са коришћењем додатне опције `.2` за прецизност у
спецификатору конверзије, на излазу би се исписали бројеви `4.85`, `5.00` и
`5.10`, па у овом случају, свакако је једноставије прочитате резултате у
оптималној нотацији.

## Форматирани улаз

За унос реалних бројева такође важи општи облик функције `scanf()`

```text
scanf(format, lista_adresa);
```

где `format` увек почиње знаком `%` и има општи облик:

```text
%[dodatne_opcije]simbol_konverzije
```

а додатне опције могу бити `*`, `širina` и `dužina`.

Реалне бројеве можеш уносити и у децималној и у научној нотацији.

Нека је задатак да напишеш програм у програмском језику C који ће се на
стандардном излазу исписати у оптимизованој нотацији дужина пута на релацији
Београд - Вршац и релацији Вршац - Београд у киломентрима, које се уносе са
стандардног улаза. Приликом тестирања програма унеси дужину пута Београд -
Вршац као реалан број у децималној нотацији `86.400000`, а дужиму пута Вршац -
Београд као реалан број у научној нотацији `8.64e1`.

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    double bgvs, vsbg;
    scanf("%lf%lf", &bgvs, &vsbg);
    printf("%lg %lg", bgvs, vsbg);
}
```

Без обзира у којој нотацији се реалан број уноси, улазном конверзијом се
податак обрађује и на исти начин записује у меморији.

```text
86.400000
8.64e1
86.4 86.4
```
