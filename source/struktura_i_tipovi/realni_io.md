# Унос и приказ реалних бројева

Као и за целобројни и знаковни тип, за унос и приказ реалних бројева користићеш
функције форматираног улаза и излаза `scanf()` и `printf()`.

:::{admonition} Напомена
:class: warning

У [табели у прилогу](../prilozi/tipovi_podataka.md) можеш видети да се за сваки
реални тип података може користи час осам симбола конверзије `f`, `F`, `g`,
`G`, `e`, `E`, `a` и `A` приликом формирања спецификатора конверзије.

Разлика између спецификатора у којима се користе мала и велика слова је само у
излазу. Уколико је на излазу потребно исписати слово, спецификатори са малим
словима на излазу исписаће све малим словима (нпр. `inf`, `nan` и `e`), док ће
они са великим словима исписати све великим словима (нпр. `INF`, `NAN` и `E`).
Значи, разлике су само естетске, а не и сусштинске, па да на даље можеш
користити нпр. само спецификаторе са малим словима.

Симболи конверзије у спецификаторима за рад са хексадекадним реалним бројевима
`a` и `A` уведени су тек каснијим **C99** стандардном и њих нећеш користити у
овом курсу.

Сада се број симбола коверзије за спецификаторе конверзије које требаш научити
свео са осам на три: `f`, `g` и `e`.
:::

## Форматирани излаз

За приказ реалних бројева такође важи општи облик функције `printf()`

```text
printf(format, lista_argumenata);
```

где `format` увек почиње знаком `%` и има општи облик:

```text
%[dodatne_opcije]simbol_konverzije
```

а општи облик спецификатора конверзије са додатним опцијама је:

```text
%[parametri][širina][.preciznost][dužina]simbol_konverzije
```

Знак `%` и `simbol_konverzije` су обавезни елементи, а између њих можеш
додатно навести, по датом редоследу и следеће необавезне елементе:

- **параметар `–`** означава да се излазни податак поравна у пољу улево
(подразумевано је поравнање удесно и додавање размака с леве стране),
- **параметар `+`** означава да се испред позитивног излазног податка испише
знак плус (подразумевано је да је излазни податак без знака позитиван),
- **параметар *размак*** означава да треба оставити једно празно место испред
означеног излазног податка, ако податак нема исписан ни један знак.
- **параметар `#`** означава обавезан испис децималне тачке и за излазне
податке који немају разломљени део броја.
- **параметар `0`** означава да се приликом поравнања удесно, са леве стране
излазних података дописују нуле уместо размака.
- `širina` је целобројна вредност која задаје минималну ширину поља, тј. укупан
број позиција коју заузима излазни податак (уз допуну размацима са лева). Ако
је за приказ излазног података потребно више позиција, поље се аутоматски
проширује за потребан број места.
- `.preciznost` је целобројна вредност која задаје број децималних места за
симболе `f` и `e`, односно, број цифара за симбол `g`.
- `dužina` се задаје карактером `l` за `double` и `L` за `long double` тип.

Уместо ширине поља може се ставити знак `*` након чега се вредност за
минималну ширину поља наводи у листи аргумената функције који мора бити
целобројног типа `int` и претходити идентификатору променљиве која се исписује.
Исто важи и за прецизност.

У лекцији о реалном типу научио си да се реални бројеви представљају као
бројеви са покретном тачком, и то на више начина. За испис бројева у
**нотацији са децималном тачком** користи се спецификатор конверзије `%f` ако
је податак дефинисан типом `float`, односно `%lf`, ако је дефинисан типом
`double`.

Нека је задатак да напишеш програм у програмском језику C који ће на стандардни
излаз исписати вредност иницијализоване реалне константе `pi`, која је
иницијализована на следећи начин:

```c
const double pi = 3.14159265358979323846;
```

Једноставно решење овог задатка може да изгледа овако:

```c
#include <stdio.h>

int main(void)
{
    const double pi = 3.14159265358979323846;
    printf("%lf", pi);
}
```

На стандардном излазу исписаће се вредност константе `pi` као реалан број у
децималној нотацији, заокружен на шест децималних места:

```text
3.141593
```

Научио си да реални типови имају одређену прецизност, па ако желиш да прикажеш
више децимала константе `pi`, на пример десет, можеш да користиш додатну опцију
`.preciznost` у спецификатору конверзије:

```c
#include <stdio.h>

int main(void)
{
    const double pi = 3.14159265358979323846;
    printf("%.10lf", pi);
}
```

Сада ће се на стандардном излазу исписати вредност константе `pi` као реалан
број у децималној нотацији, заокружен на десет децималних места:

```text
3.1415926536
```

Води рачуна о томе да, иако у поступку иницијализације податку реалног типа
доделиш број са више значајних цифара него што је предвиђено, прецизност ће
остати не промењена. Ако би у претходном примеру покушао да испишеш свих
двадесет децимала констане `pi` наведених у иницијализацији, само ће се
првих петнаест исписати коректно, а остала места биће попуњена неким насумично
одабраним цифрама (3.141592653589793**11600**).

За испис бројева у **научној нотацији** користи се спецификатор конверзије `%e`
ако је податак дефинисан типом `float`, односно `%le`, ако је дефинисан типом
`double`. Реалан број у овој нотацији записује се навођењем мантису, слова `е`
које представља основу и експонента.

Нека је сада задатак да напишеш програм у програмском језику C који ће на
стандардни излаз исписати капацитивност кондензатора од $39nF$ u Faradima
($39nF=0.000000039F$)

```c
#include <stdio.h>

int main(void)
{
    double c = 0.000000039;
    printf("%le", c);
}
```

Резултат на стандардном излазу представља број у научној нотацији:

```text
3.900000e-08
```

У овом случају, свакако је лакше протумачити број $3.9\times{10^{-8}}$ него
бројати нуле у децималном запису $0.000000039$.

За испис бројева у **оптимизованој нотацији** користи се спецификатор
конверзије `%g` ако је податак дефинисан типом `float`, односно `%lg`, ако је
дефинисан типом `double`. Из реалног броја у овој нотацији бришу се непотребне
нуле.

Нека је сада задатак да напишеш програм у програмском језику C који ће у три
реда стандардног излаза исписати три резултата Николиних скокова у даљ који су
износили $4.85$, $5$ и $5.1$ метар.

```c
#include <stdio.h>

int main(void)
{
    double skok_1 = 4.85, skok_2 = 5.0, skok_3 =5.1;
    printf("%lg\n%lg\n%lg", skok_1, skok_2, skok_3);
}
```

Бројеви на стандардном излазу записани су у оптималној нотацији:

```text
4.85
5
5.1
```

У нотацији са децималном тачком, са коришћењем додатне опције `.2` за
прецизност у спецификатору конверзије, на излазу би се исписали бројеви `4.85`,
`5.00` и `5.10`, па у овом случају, свакако је једноставије прочитате резултате
у оптималној нотацији.

## Форматирани улаз

За унос реалних бројева такође важи општи облик функције `scanf()`

```text
scanf(format, lista_adresa);
```

где `format` увек почиње знаком `%` и има општи облик:

```text
%[dodatne_opcije]simbol_konverzije
```

а општи облик спецификатора конверзије са додатним опцијама је:

```text
%[*][širina][dužina]simbol_konverzije
```

Знак `%` и `simbol_konverzije` су обавезни елементи, а између њих можеш
додатно навести, по датом редоследу и следеће необавезне елементе:

- `*`, је карактер који означава да ће се улазни податак прочитати и
игнорисати,
- `širina`, је целобројна вредност која задаје највећи број карактера улазног
податка,
- `dužina`, се задаје карактером `l` за `double`, или `L` за `long double`.

Реалне бројеве можеш уносити и у нотацији са децималном тачком и у научној
нотацији.

Нека је задатак да напишеш програм у програмском језику C који ће се на
стандардном излазу исписати у оптимизованој нотацији дужина пута на релацији
Београд-Вршац и релацији Вршац-Београд у киломентрима, које се уносе са
стандардног улаза. Приликом тестирања програма унеси дужину пута Београд-Вршац
као реалан број у нотацији са децималном тачком `86.400000`, а дужиму пута
Вршац-Београд као реалан број у научној нотацији `8.64e1`.

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    double bgvs, vsbg;
    scanf("%lf%lf", &bgvs, &vsbg);
    printf("%lg %lg", bgvs, vsbg);
}
```

Без обзира у којој нотацији се реалан број уноси, улазном конверзијом се
податак обрађује и на исти начин записује у меморији.

```text
86.400000
8.64e1
86.4 86.4
```
