# Набројиви тип података

## Дефинисање набројивог скупа података

Могао си до сада да приметиш да програмски језик C нуди прилично оскудан
избор типова података. У реалном свету, поред бројева и карактера, често ћеш
наићи на стандардне скупове података који нису дефинисани у програмском језику
C, као на пример називи дана у недељи или називи месеца у години. Овакве
скупове података можеш сам дефинисати помоћу кључне речи `enum`.

Пошто поменути скупови имају коначан број вредности називају се набројивим
*(енгл. enumeration)*. У набројивом скуповима, елементе скупа чине
идентификатори, а општи облик дефинисања набројивог скупа података је:

```text
enum ime_skupa { identifikator_1, identifikator_2, ... identifikator_n };
```

На пример, напиши програм у програмском језику C у којем ће бити дефинисан
набројиви скуп података `radni_dan` чији су елементи: `pon`, `uto`, `sre`,
`cet` и `pet`.

```c
#include <stdio.h>

int main(void)
{
    enum radni_dan { pon, uto, sre, cet, pet };
    return 0;
}
```

У претходно примеру, идентификаторима `pon`, `uto`, `sre`, `cet` и `pet` редом
су додељене целобројне вредности `0`, `1`, `2`, `3` и `4` типа `int`. Ако би
желео да дефинишеш променљиву `dan` која има вредност `uto`, то можеш учинити
доделом идентификатора `uto`:

```c
#include <stdio.h>

int main(void)
{
    enum radni_dan { pon, uto, sre, cet, pet };
    enum radni_dan dan = uto;
    return 0;
}
```

или доделом вредности `1`:

```c
#include <stdio.h>

int main(void)
{
    enum radni_dan { pon, uto, sre, cet, pet };
    enum radni_dan dan = 1;
    return 0;
}
```

Иницијализацију вредности елемената можеш вршити и сам приликом дефиниције
`enum` скупа, где неки елементи могу бити иницијализовани, а неки само
декларисани. У следећем програму:

```c
#include <stdio.h>

int main(void)
{
    enum nastavna_godina { sep = 9, okt, nov, dec, jan = 1, feb, mar, apr, maj, jun };
    return 0;
}
```

елемент `sep` иницијализован је са целобројном вредношћу `9`, потом је елементу
`okt` додељена вредност `10`, елементу `nov` вредност `11`, елементу `dec`
вредност `12`, па је елемент `jan` иницијализован са вредношћу `1`, елементу
`feb` додељена је вредност `2`, елементу `mar` вредност `3` и тако даље.
Правило за доделу вредности елементима је једноставно: ако први елемент није
иницијализован добиће вредност нула, односно, ако било који елемент осим првог
није иницијализован добиће вредност претходног елемента увећану за један.

Дозвољено је и да различити елементи набројивог скупа имају исту вредност. У
следећем програму дефинисана су стања сервера:

```c
#include <stdio.h>

int main(void)
{
    enum server { ukljucen = 1, onlajn = 1, iskljucen = 0, oflajn = 0, greska = 0 };
    return 0;
}
```

где су јединицама дефинисана жељена стања (`ukljucen` и `onlajn`), а нулама
нежељена (`iskljucen`, `oflajn` и `greska`). С друге стране, није дозвољено да
различити елементи набројивог скупа буду дефинисани истим идентификатором, чак
ни у различитим скуповима. Компајлер ће у следећем програму јавити грешке:

```c
#include <stdio.h>

int main(void)
{
    enum dan_u_nedelji { pon, uto, sre, cet, pet, sub, ned };
    enum radni_dan { pon, uto, sre, cet, pet };
    return 0;
}
```

јер је програмер у скупу `radni_dan` покушао да редефинише идентификаторе
`pon`, `uto`, `sre`, `cet` и `pet` које је већ користио у скупу
`dan_u_nedelji`.

## Дефинисање набројивог типа података

У претходној лекцији научио си како да дефинишеш изведене типове података
помоћу кључне речи `typedef`. Комбинацијом кључних речи `typedef` и `enum`
можеш дефинисати сопствени набројиви тип података. Општи облик дефинисања
набројивог типа података је:

```text
typedef enum { identifikator_1, identifikator_2, ... identifikator_n } ime_tipa;
```

На пример, напиши програм у програмском језику C у којем ће бити дефинисан
набројиви тип података `radni_dan` који може да има вредности `pon`, `uto`,
`sre`, `cet` и `pet`, и у којем је иницијализована променљива `dan` типа
`radni_dan` са вредношћу `uto`:

```c
#include <stdio.h>

int main(void)
{
    typedef enum { pon, uto, sre, cet, pet } radni_dan;
    radni_dan dan = uto;
    return 0;
}
```

За дефинисање набројивог типа података важе иста правила као и за дефинисање
набројивог скупа података: променљивама набројивог типа могу се доделити
идентификатори из набројивог скупа или одговарајуће целобројне вредности;
иницијализација појединих или свих вредности у набројивом скупу може се вршити
и у самој дефиницији набројивог типа; дозвољено је да различити елементи
набројивог скупа имају исту вредност, али није дозвољено да буду дефинисани
истим идентификатором.
