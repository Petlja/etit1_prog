# Унос и приказ целих бројева

Пошто програмски језик C потиче са UNIX система, он све уређаје третира као
датотеке. Тако и податке које требаш унети у програм или исписати из програма
можеш посматрати као датотеке које садрже низове сукцесивних знакова који се
називају токови *(енгл. streams)*.

Улазни подаци читају се из тока `stdin`, излазни уписују у ток `stdout`, а
кодови грешака насталих при извршењу програма уписују се у ток `stderr`.
Извориште података за унос може бити тастатура, било који улазни уређај или
датотека, док одредиште за испис може бити екран, штампач, било који излазни
уређај или датотека. Ток `stdin` назива се стандардни улаз, ток `stdout`
стандардни излаз и ток `stderr` стандардни излаз за грешке.

```{image} images/tokovi.png
:width: 100%
:align: center
:alt: Токови
```

У првом разреду, једино извориште података које ћеш користити је тастатура, а
одредиште за испис података екран. Коришћење других изворишта и одредишта биће
теме у другом разреду.

Подаци се са тастатуре уносе као низ знакова, у меморији представљају у
бинарном облику одређеног типа и на екрану у текстуалном облику. У току преноса
знакова унешених са тастатуре у бинарни облик одређеног типа у меморији врши се
**улазна конверзија**. У току преноса бинарних података одређеног типа из
меморије у текстуални облик који се исписује на екрану врши се
**излазна конверзија**.

У програмском језику C наредбе за улаз/излаз формирају се коришћењем посебних
функција дефинисаних у библиотеци `stdio.h`. У овој библиотеци дефинисано је
више функција које се могу користити за улаз/излаз, а на почетку биће обрађење
само функције `printf()` за излаз и `scanf()` за улаз.

## Функција за приказ података

Функцију `printf()` до сада си користио само за испис текста који се налазио
између наводника. Међутим, ова функција има и могућност исписа података било
ког типа на стандардном излазу тј. на екрану уз примену излазне конверзије.
Каже се да ова функција обавља **форматирани излаз** јер као аргумент користи
низ знакова којим се управља конверзијом, а који се назива формат.

**Формат** је низ знакова записан између наводника који може наизменично
да садржи текст (укључујући и размаке), управљачке карактере и спецификаторе
конверзија. **Спецификатор конверзије** прецизно одређује начин конверзије
податка који се исписује. Увек почиње знаком `%` и има општи облик:

```text
%[dodatne_opcije]vrsta_konverzije
```

Листа свих спецификатора конверзије налази се у
[табели у прилогу](../prilozi/tipovi_podataka.md).
Место на коме се исписује излазни податак назива се **поље**. Број знакова који
се може сместити у неко поље назива се **ширина поља**.

Библиотечка функција `printf()` има следећи општи облик:

```text
printf(format, lista_argumenata);
```

где, како је већ објашњено, формат садржи низ знакова, док листа аргумената
садржи вредности које ће бити исписане, обично у форми идентификатора или
израза.

### Приказ целобројних података

У [табели у прилогу](../prilozi/tipovi_podataka.md) можеш видети да је
спецификатор конверзије `%d` спецификатор за целобројни податак типа `int`.
Ако су променљиве `ana`, `nikola`, `marko` и `milica` иницијализоване са бројем
година које Ана, Никола, Марко и Милица имају на данашњи дан, онда можеш
написати програм који ће те податке исписати на стандардни излаз на следећи
начин:

```c
#include <stdio.h>

int main(void)
{
    int ana = 16, nikola = 17, marko = 15, milica = 18;
    printf("Ana ima %d godina.\n", ana);
    printf("Nikola ima %d godina.\n", nikola);
    printf("Marko ima %d godina.\n", marko);
    printf("Milica ima %d godina.\n", milica);
    return 0;
}
```

што ће на стандардном излазу дати следећи резултат:

```text
Ana ima 16 godina.
Nikola ima 17 godina.
Marko ima 15 godina.
Milica ima 18 godina.
```

Наравно, у оквиру једне `printf()` функције можеш користи више поља истовремено
и претходни програм можеш написати и овако:

```c
#include <stdio.h>

int main(void)
{
    int ana = 16, nikola = 17, marko = 15, milica = 18;
    printf("Ana %d, Nikola %d, Marko %d, Milica %d", ana, nikola, marko, milica);
    return 0;
}
```

што ће на стандардном излазу дати следећи резултат:

```text
Ana 16, Nikola 17, Marko 15, Milica 18
```

Додатне опције које можеш користити у спецификатору конверзије омогућују да
прецизно дефинишеш како ће изгледати испис на главном излазу. Општи облик
спецификатора конверзије са додатним опцијама за функцију `printf()` је:

```text
%[parametri][širina][.preciznost][dužina]simbol_konverzije
```

Знак `%` и `simbol_konverzije` као у
[табели у прилогу](../prilozi/tipovi_podataka.md)
су обавезни елементи, а између њих можеш додатно навести, по датом редоследу и
следеће необавезне елементе:

- параметар `–` означава да се вредност на излазу поравна у пољу улево
(подразумевано је поравнање удесно и додавање размака с леве стране),
- параметар `+` означава да се на излазу испред позитивне бројчане вредности
испише знак плус (подразумевано је да је број без знака позитиван),
- параметар размак означава да испред означене вредности која нема ни `+` ни
`–` треба оставити једно празно место,
- параметар `#` означава обавезно исписивање `0` за вредности у окталном
бројевном систему, `0х` или `0Х` за вредности у хексадекадном бројевном систему
и децималне тачке `.` за реалне бројеве иако немају разломљени део броја.
- параметар `0` означава да се код бројчаних вредности, приликом поравнања
удесно, са леве стране дописују нуле уместо размака.
- `širina` је целобројна вредност која задаје минималну ширину поља, тј. укупан
број позиција коју заузима излазни податак (уз допуну размацима са леве
стране). Уколико је за приказ излазне вредности потребно више позиција, поље се
аутоматски проширује за потребан број места.
- `.preciznost` је целобројна вредност која задаје број децимала броја, а коју
коју можеш користити у раду са реалним бројевима, односно бројевима са
покретном тачком.
- `dužina`, cлово `h` испред симбола конверзије `d`, `i`, `u`, `o`, `x` и `X`
означава да је у питању кратак (`short`) целобројни податак, слово `l` испред
симбола конверзије `d`, `i`, `u`, `o`, `x` и `X` означава да је у питању дуги
(`long`) целобројни податак, слово `L` испред симбола конверзије `f`, `F`, `e`,
`E`, `g` и `G` означава да је у питању податак типа `long double`, онако како
је написано у [табели у прилогу](../prilozi/tipovi_podataka.md).

На пример, коришћење параметра `0` и опције `širina` демонстрирај решавањем
следећег задатка: Ако је данас први септембар 2023. године, на стандардни излаз
испиши четири варијанте писања данашњег датума и то:

- Д.М.Г. формат, где поља нису фиксне ширине *(нпр. 1.9.2023.)*,
- ДД-ММ-ГГГГ формат, где су поља фиксне ширине *(нпр. 01-09-2023)*,
- ММ-ДД-ГГГГ формат, где су поља фиксне ширине *(нпр. 09-01-2023)*, као у САД-у
и
- ГГГГ-ММ-ДД формат, где су поља фиксне ширине *(нпр. 2023-09-01)*, по ISO 8601
стандарду.

```c
#include <stdio.h>

int main(void)
{
    int d = 1;
    int m = 9;
    int g = 2023;
    printf("%d.%d.%d.\n", d, m, g);
    printf("%02d-%02d-%04d\n", d, m, g);
    printf("%02d-%02d-%04d\n", m, d, g);
    printf("%04d-%02d-%02d", g, m, d);
    return 0;
}
```

На стандардном излазу исписаће се тражене четири варијанте писања датума:

```text
1.9.2023.
01-09-2023
09-01-2023
2023-09-01
```

Уместо ширине поља може се ставити знак `*` након чега се вредност за
минималну ширину поља наводи у листи аргумената функције који мора бити
целобројног типа `int` и претходити идентификатору променљиве која се исписује.
Исто важи и за прецизност.

## Функције за унос података

До сада си научио да на стандардни излаз исписујеш податке које си сам
дефинисао у оквиру програма. Међутим, у већини случајева у пракси, подаци нису
унапред познати, односно, корисник за кога се програм израђује треба да уноси
своје податке. Функција `scanf()` чита податке са стандардног улаза тј. са
тастатуре уз примену улазне конверзије. Каже се да ова функције обављају
**форматирани улаз** јер као аргумент користи низ знакова којим се управља
конверзијом, а који се назива формат.

Као и у случају функције `printf()`, **формат** је низ знакова записан између
наводника који може наизменично садржати текст (укључујући и размаке),
управљачке карактере и спецификаторе конверзија. **Спецификатор конверзије**
прецизно одређује начин конверзије податка који се исписује. Увек почиње знаком
`%` и има општи облик:

```text
%[dodatne_opcije]vrsta_konverzije
```

Листа свих спецификатора конверзије налази се у
[табели у прилогу](../prilozi/tipovi_podataka.md).

Библиотечка функција `scanf()` има следећи општи облик:

```text
scanf(format, adrese_promenljivih);
```

где `format` садржи врсте улазник конверзија, а `adrese_promenljivih` листу
адреса променљивих, записаних у облику `&identifikator` у које се уносе
конвертоване вредности учитаних података. Општи облик спецификатора конверзије
за функцију `scanf()` је следећи:

```text
%[*][širina][dužina]simbol_konverzije
```

Знак `%` и `simbol_konverzije` из
[табеле у прилогу](../prilozi/tipovi_podataka.md)
су обавезни елементи, док се између њих могу додатно навести, по датом
редоследу и следећи необавезни елементи:

- `*` прескок додељивања
- `širina`, максимална ширина улазног поља задата целим бројем
- `dužina`, cлово `h` испред симбола конверзије `d`, `i`, `u`, `o`, `x`, `e`,
`f`, и `g` означава да се ради о кратком (`short`) податку, a слово `l` да се
ради о дугом (`long`) податку, онако како је написано у
[табели у прилогу](../prilozi/tipovi_podataka.md).

:::{admonition} Упозорење
:class: warning

Функција `scanf()` сматра се небезбедном функцијом јер не проверава величину
унетих података. Ово се показало изузетно опасно, нарочито када је у питању
унос низа карактера *(енгл. string)*, о чему ћеш учити у другом разреду. Ако
корисник програма унесе дужи низ карактера од предвиђеног, може се десити да
се у оперативној меморији препишу подаци који су смештени близу тог низа. То
може да узрокује пуцање програма, грешке у раду оперативног система и озбиљне
безбедносне пропусте. Због свега наведеног, у новијим верзијама Microsoft C/C++
компајлера, моћи ћеш да користиш функцију `scanf()` само уз обавезно навођење
директиве `#define _CRT_SECURE_NO_WARNINGS` на почетку програма. Исто ће важити
и за групу функција за унос коју ћеш учити у другом разреду. Ова директива неће
сметати другим компајлерима, док алтернативна функција `scanf_s()` коју
Microsoft C/C++ компајлер нуди, у другим компајлерима неће бити препозната као
библиотечка функција.
:::

Сада можеш писати програме који читају податке са стандардног улаза и
исписују податке на стандардни излаз. На пример, напиши програм који од
корисника тражи да на стандардни улаз унесе колико има година, а потом тај
податак исписује на стандардни излаз:

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    int godine;
    printf("Koliko imas godina: ");
    scanf("%d", &godine);
    printf("Uneo si broj %d", godine);
    return 0;
}
```

Извршавање овог програма у конзоли може изгледати овако:

```text
Koliko imas godina: 15
Uneo si broj 15
```

Jедним позивом `scanf()` функције можеш унети више података истовремено. На
пример, напиши програм који од корисника тражи да на стандардни улаз унесе
редом колико има година и колико је висок у центиметрима, па потом унете
податке испише на стандардни излаз:

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    int godine, visina;
    printf("Unesi redom: koliko imas godina i svoju visinu u cm: ");
    scanf("%d%d", &godine, &visina);
    printf("Ti imas %d godina i visok si %d cm.", godine, visina);
    return 0;
}
```

Резултат извршавања овог програма и интеракције са корисником може да изгледа
овако:

```text
Unesi redom: koliko imas godina i svoju visinu u cm: 15 176
Ti imas 15 godina i visok si 176 cm.
```

Програм ће исто радити и ако корисник притисне тастер `ENTER` након броја `15`.

```text
Unesi redom: koliko imas godina i svoju visinu u cm: 15
176
Ti imas 15 godina i visok si 176 cm.
```
