# Конверзије типова

Када се операције извршавају над операндима различитих типова, долази до
аутоматске конверзије типова где се операнди типова `char` и `short` увек
конвертују у тип `int`, па потом остали на основу хијерахије:

```c
int < unsigned < long < unsigned long < float < double < long double
```

где се оператор нижег приоритета увек конвертује у оператор вишег. Мораш бити
изузетно опрезан када вршиш аритметичке операције над операндима различитих
типова како не би добио нежељене, непрецизне или нетачне резултате!

Нека је задатак да се саберу вредности променљивих `int x = 'a'` и
`char y = 3`, па резултат додели променљивој `double z` и испише на стандардни
излаз.

```c
#include <stdio.h>

int main(void)
{
    int x = 'a';
    char y = 3;
    double z;
    z = x + y;
    printf("%lf", z);
    return 0;
}
```

Као резултат извршавања датог програма на стандардном излазу исписао се реалан
број `100.000000` Зашто? Карактер `'a'` додељен је променљивој `x` типа `int`,
цео број `3` додељен је променљивој `y` типа `char`, и декларисана је
променљива типа `double`. Пре него што је извршено сабирање `x + y`, променљива
`y` конвертована је у тип `int`. Потом је израчунат збир `97 + 3`, па је
резултат `100` типа `int` конвертован у `100.0` типa `double` и додељен
променљивој `z`.


. Потом је израчунат збир `97 + 3`, па је целобројна вредност `100`
конвертована у реалну `100.0`.

Ако конверзију типова извршава компајлер аутоматски, као у примеру изнад, онда
се таква конверзија назива **имплицитна конверзија типова**.

Нека је сада задатак да се поделе вредности променљивих `int x = 'a'` и
`char y = 3`, па резултат додели променљивој `double z` и испише на стандардни
излаз.

```c
#include <stdio.h>

int main(void)
{
    int x = 'a';
    char y = 3;
    double z;
    z = x / y;
    printf("%lf", z);
    return 0;
}
```

Имплицитне конверзије типова ће бити извршене као и у примеру изнад и на
стандардни излаз биће исписан резултат `32.000000`. Зашто је резултат
`32.000000`, а не `32.333333`, када променљива `z` јесте типа `double`?
Зато што су у тренутку дељења променљиве `x` и `y` биле целобројног типа `int`,
па је тек након дељења извршена имплицитна конверзија резултата у `double`.

Код дељења две целобројне вредности оператором `/`, као резултат добија се само
цео део броја, док се разломљени део одбацује, односно, врши се
**целобројно дељење**. **Остатак приликом целобројног дељења** добија се
оператором `%`.

Да ли је онда могуће у претходном примеру добити резултат у виду реалног броја
`32.333333`? Јесте могуће експлицитном конверзијом типова.
**Експлицитна конверзија типова**, односно **кастовање типова** подразумева да
програмер сам дефинише како ће се конверзија одвијати користећи каст операторе,
односно, наводећи жељени тип у заградама испред израза.

```c
#include <stdio.h>

int main(void)
{
    int x = 'a';
    char y = 3;
    double z;
    z = (double)x / (double)y;
    printf("%lf", z);
    return 0;
}
```

У овој верзији решења, након имплицитних конверзија, променљиве `x` и `y` су
типа `int` и имају вредности `97` и `3`. Пре него што је извршена операција
дељења, променљиве `x` и `y` кастоване су у тип `double`. Резултат дељења два
броја типа `double` биће типа `double`, у овом случају `32.333333`.
