# Конверзије типова

Када се операције извршавају над операндима различитих типова, долази до
аутоматске конверзије типова где се операнди типова `char` и `short` увек
конвертују у тип `int`, па потом остали на основу хијерахије:

```c
int < unsigned < long < unsigned long < float < double < long double
```

где се оператор нижег приоритета увек конвертује у оператор вишег. Мораш бити
изузетно опрезан када вршиш операције над операндима различитих типова како не
би добио нежељене непрецизне или нетачне резултате!

Нека је задатак да напишеш програм у програмском језику C у којем се сабирају
вредности променљивих `int x = 'a'` и `char y = 3`, па се резултат сабирања
додељује променљивој `double z` и вредност променљиве `z` исписује на
стандардни излаз.

```c
#include <stdio.h>

int main(void)
{
    int x = 'a';
    char y = 3;
    double z = x + y;
    printf("%lf", z);
    return 0;
}
```

На стандардном излазу исписаће се следећи резултат:

```text
100.000000
```

Зашто?

- Карактер `'a'` додељен је променљивој `x` типа `int`. Иако је додељена
вредност дефинисана као карактер, променљива је декларисана типом `int`, па је
ASCII вредност `97` сачувана у променљивој типа `int`.
- Цео број `3` додељен је променљивој `y` типа `char`. Иако је додељена
вредност декларисана као број, променљива је декларисана типом `char`, па је
вредност `3` сачувана у променљивој типа `char`.
- Израз `x + y` додељен је променљивој `z` типа `double`. Пре него што је
извршено сабирање `x + y`, променљива `y` конвертована је у тип `int`. Потом је
израчунат збир `97 + 3`, па је резултат `100`, који је типа `int`, конвертован
у `100.0` типa `double` и додељен променљивој `z`.

Ако конверзију типова извршава компајлер аутоматски, као у претходном примеру,
онда се таква конверзија назива **имплицитна конверзија типова**.

Нека је сада задатак да напишеш програм у програмском језику C у којем се деле
вредности променљивих `int x = 'a'` и `char y = 3`, па се резултат дељења
додељује променљивој `double z` и вредност променљиве `z` исписује на
стандардни излаз.

```c
#include <stdio.h>

int main(void)
{
    int x = 'a';
    char y = 3;
    double z = x / y;
    printf("%lf", z);
    return 0;
}
```

На стандардном излазу исписаће се следећи резултат:

```text
32.000000
```

Зашто је исписан резултат `32.000000`, а не `32.333333`, када је променљива `z`
типа `double`? Зато што су у тренутку дељења променљиве `x` и `y` биле
типа `int`, па тако и резултат дељења `32`. Тек је након операције дељења
извршена имплицитна конверзија резултата у `double`.

Код дељења две целобројне вредности оператором `/`, као резултат добија се само
цео део броја, док се разломљени део одбацује, односно, врши се
**целобројно дељење**. **Остатак приликом целобројног дељења** добија се
оператором `%`.

Да ли је онда могуће у претходном примеру добити резултат у виду реалног броја
`32.333333`? Јесте, али експлицитном конверзијом типова.
**Експлицитна конверзија типова**, односно **кастовање типова** подразумева да
програмер сам дефинише како ће се конверзија одвијати користећи каст операторе,
односно, наводећи жељени тип у заградама испред израза.

```c
#include <stdio.h>

int main(void)
{
    int x = 'a';
    char y = 3;
    double z = (double)x / (double)y;
    printf("%lf", z);
    return 0;
}
```

На стандардном излазу сада ће се исписати следећи резултат:

```text
32.333333
```

У овој верзији решења, пре него што је извршена операција дељења, променљиве
`x` и `y` кастоване су из типа `int` у тип `double`. Резултат дељења два реална
броја типа `double` биће типа `double`, у овом случају `32.333333`. Да би се
добио исти резултат било је довољно кастовати само дељеник или само делилац из
типа `int` у тип `double`.
