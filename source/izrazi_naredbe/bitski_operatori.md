# Оператори над битовима

Цели бројеви типа `int` се чувају у меморији рачунара у једној речи
*(енгл. word)*, која се састоји од $4$ бајта, односно $32$ бита. То значи да
неозначен цео број може добити вредности од $0$ до $4,294,967,295$, односно до
$2^{32}-1$. Бинарно, $0$ се може представити као
`00000000 00000000 00000000 00000000`, а $4,294,967,295$ као
`11111111 11111111 11111111 11111111`.

Међутим, цели бројеви могу бити и негативни, односно могу бити и означени. Ако
је број означен први бит од $32$ бита мора се жртвовати за знак. По конвенцији,
ако је први бит `0`, онда је број позитиван, односно, ако је први бит `1` онда
је број негативан. Пошто је остао још $31$ бит, значи да цео број може добити
вредности од $-2,147,483,648$ до $2,147,483,647$, односно до $\pm{2^{31}}-1$.
Бинарно, $-2,147,483,648$ се може представити као
`11111111 11111111 11111111 11111111`, а $2,147,483,647$ као
`01111111 11111111 11111111 11111111`.

За рад над битовима броја у програмском језику C користе се битски оператори
*(енгл. Bitwise Operators)*. Сви битски оператори су бинарни оператори јер
користе два операнда (а не зато што раде над бинарним бројевима). Доступни су
следећи оператори:

- `&`, битски оператор И *(енгл. Bitwise AND)*,
- `|`, битски оператор ИЛИ *(енгл. Bitwise OR)*,
- `^`, битски оператор ЕКСИЛИ *(енгл. Bitwise XOR)*,
- `~`, битски оператор инвертовања *(енгл. Bitwise Complement)*,
- `<<`, битски оператор померања у лево *(енгл. Shift Left)* и
- `>>`, битски оператор померања у десно *(енгл. Shift Right)*.

## Битски оператор И

```text
-------------------------
|   a   |   b   | a & b |
|-------+-------+-------|
|   1   |   1   |   1   |
|   1   |   0   |   0   |
|   0   |   1   |   0   |
|   0   |   0   |   0   |
-------------------------
```

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    int a, b;
    scanf("%d%d", &a, &b);
    printf("%d", a & b);
    return 0;
}
```

```text
a = 2       00000010
b = 3       00000011
            --------
a & b = 2   00000010
```

## Битски оператор ИЛИ

```text
-------------------------
|   a   |   b   | a | b |
|-------+-------+-------|
|   1   |   1   |   1   |
|   1   |   0   |   1   |
|   0   |   1   |   1   |
|   0   |   0   |   0   |
-------------------------
```

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    int a, b;
    scanf("%d%d", &a, &b);
    printf("%d", a | b);
    return 0;
}
```

```text
a = 2       00000010
b = 3       00000011
            --------
a | b = 3   00000011
```

## Битски оператор ЕКСИЛИ

```text
-------------------------
|   a   |   b   | a ^ b |
|-------+-------+-------|
|   1   |   1   |   0   |
|   1   |   0   |   1   |
|   0   |   1   |   1   |
|   0   |   0   |   0   |
-------------------------
```

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    int a, b;
    scanf("%d%d", &a, &b);
    printf("%d", a ^ b);
    return 0;
}
```

```text
a = 2       00000010
b = 3       00000011
            --------
a ^ b = 1   00000001
```

## Битски оператор инвертовања

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    int a;
    scanf("%d%d", &a);
    printf("%d", ~a);
    return 0;
}
```

```text
a = 2       00000010
~a = -3    -00000011
```

## Битски оператор померања у лево (`<<`)

Битски оператор померања у лево `<<` је бинарни оператор помоћу којег можеш да
помериш битове целобројне променљиве за одређени број места у лево. Битови
првог операнда померају се улево за број позиција дефинисаних другим операндом.
Након померања, на празна места која се стварају на десној страни додају се
нуле.

На пример, нека су иницијализоване променљиве `int a = 48, b = 1;`. Израз
`a << b` значио би да треба померити битове броја `a` за `b` места у лево,
односно да треба померити битове броја `48` за `1` место у лево.

Број `48` може се представити као бинаран број на следећи начин:

```text
00000000 00000000 00000000 00110000
```

Померањем битова броја 48 за једно места улево добија се број `96`:

```text
00000000 00000000 00000000 01100000
```

Програм у програмском језику C који илуструје овај пример изгледао би овако:

```c
#include <stdio.h>

int main(void)
{
    int a = 48, b = 1;
    printf("%d", a << b);
    return 0;
}
```

### Грешке у раду са битским оператором померања у лево

Ако је вредност првог операнда негативна, онда ће резултат операције померања
улево бити недефинисан.

```c
#include <stdio.h>

int main(void)
{
    int res = -48 << 1;
    printf("%d", res);
    return 0;
}
```

Microsoft C/C++ компајлер у овом случају издаје упозорење
`Warning C26453: Arithmetic overflow: Left shift of a negative signed number is undefined behavior (io.4)`.

Слично, ако је вредност другог операнда негативна или ако је већа или једнака
броју битова у првом операнду, онда ће резултат операције померања улево бити
недефинисан.

```c
#include <stdio.h>

int main(void)
{
    int res = 48 << -1;
    printf("%d", res);
    return 0;
}
```

или

```c
#include <stdio.h>

int main(void)
{
    int res = 48 << 33;
    printf("%d", res);
    return 0;
}
```

Microsoft C/C++ компајлер у оба случаја издаје упозорење
`Warning C26452: Arithmetic overflow: Left shift count is negative or greater than or equal to the operand size, which is undefined behavior (io.3)`.

Ако после операције померања улево са леве стране има битова са вредношћу `1`
за које нема места (дешава се преливање), резултат је неодређен.

```c
#include <stdio.h>

int main(void)
{
    int res = 48 << 31;
    printf("%d", res);
    return 0;
}
```

Microsoft C/C++ компајлер у овом случају издаје упозорење
`Warning C26450: Arithmetic overflow: 'operator' operation causes overflow at compile time. Use a wider type to store the operands (io.1)`.

## Битски оператор померања у десно (`>>`)

Битски оператор померања у десно `>>` је бинарни битски оператор помоћу којег
можеш да помериш битове целобројне променљиве за одређени број места у десно.
На пример, израз `a >> n` значи да треба померити битове променљиве `a` за `n`
места у десно. Сви битови са десне стране за које после померања нема места се
занемарују, док се са леве стране додају нуле.

На пример, нека је `a = 123`, а задатак је померање за два места у десно
`a >> 2`. Декадно `123` је бинарно `01111011`. Да би померио `01111011` за два
места у десно, потребно је да додаш две нуле на почетку и обришеш два последња
бита. Бинарни резултат `00011110` је декадно `30`.

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    int a;
    scanf("%d", &a);
    printf("%d", a >> 2);
    return 0;
}
```
