# Одређивање величине низа

У претходним лекцијама научио си да приликом иницијализације низа можеш да
изоставиш његову величину, односно димензију. Ако у програму постоји такав низ,
а ти желиш, на пример, да испишеш његове елементе на стандардни излаз, онда ће
ти требати величина тог низа.

Можеш сам пребројиш колико је елемената наведено током иницијализације, што
није добро решење. Ако се у коду програма касније промени број елемената који
се иницијализује, онда ћеш морати да мењаш и код у којем си експицитно навео
тај број.

Друго, боље решење је да користиш `sizeof()` оператор. У лекцији
[Оператор `sizeof()`](../izrazi_naredbe/operator_sizeof.md) научио си да
операнд `sizeof()` оператора може бити основни или изведени тип података или
израз. Како је низ изведени тип података, резултат операције биће величина
низа у бајтовима, а не број елемената у низу. Међутим, како је низ скуп
података истог типа, број елемената у низу можеш да израчунаш као количник
резултата који се добија применом оператора `sizeof()` на низ и применом
оператора `sizeof()` на први елемент низа.

Напиши програм у програмском језику C којим се у једној линији стандардног
излаза исписују твоје закључне оцене, ако су оцене наведене као елементи низа
`o[]` без наведене величине низа.

```c
#include <stdio.h>

int main(void)
{
    int o[] = { 5, 4, 5, 4, 5, 5, 4, 3, 2, 5 };
    int n = sizeof(o) / sizeof(o[0]);
    for (int i = 0; i < n; i++)
        printf("%d ", o[i]);
    return 0;
}
```

Величина низа `n` израчуната је као количник резултата који се добија применом
оператора `sizeof()` на низ и применом оператора `sizeof()` на први елемент
низа.

Треће, једнако функционално решење је да као делилац, уместо првог елемента
низа, користиш тип података којим је низ иницијализован. Претходни програм би
онда изгледало овако:

```c
#include <stdio.h>

int main(void)
{
    int o[] = { 5, 4, 5, 4, 5, 5, 4, 3, 2, 5 };
    int n = sizeof(o) / sizeof(int);
    for (int i = 0; i < n; i++)
        printf("%d ", o[i]);
    return 0;
}
```

Оператор `sizeof()` увек одређује величину **целог низа** у бајтовима. Ако је
низ делимично иницијализован, елементима којима ниси експлицитно доделио
вредност током иницијализације, аутоматски је додељена вредност `0`. У следећем
примеру:

```c
#include <stdio.h>

int main(void)
{
    int o[10] = { 5, 4, 5, 4, 5 };
    int n = sizeof(o) / sizeof(int);
    for (int i = 0; i < n; i++)
        printf("%d ", o[i]);
    return 0;
}
```

вредност променљиве $n$ је $40/4=10$ па ће се на стандардном излазу исписати:

```text
5 4 5 4 5 0 0 0 0 0
```

Исти је случај и са статичком алокацијом низа без иницијализације. Ако је
алоциран низ од `n` елемената, па након тога, у њега унет број елемената мањи
од `n`, оператор `sizeof()` вратиће опет величину целог низа, без обзира што
низ поседује елементе који нису иницијализовани. У следећем примеру:

```c
#include <stdio.h>

int main(void)
{
    int o[10];
    o[0] = 5;
    o[1] = 4;
    o[2] = 5;
    o[3] = 4;
    o[4] = 5;
    int n = sizeof(o) / sizeof(int);
    for (int i = 0; i < n; i++)
        printf("%d ", o[i]);
    return 0;
}
```

на стандардном излазу исписаће се:

```text
5 4 5 4 5 -858993460 -858993460 -858993460 -858993460 -858993460
```

У односу на претходни пример у коме су елементи од `o[5]` до `o[9]` били
аутоматски иницијализовани нулама, у овом примеру исписане вредности
`-858993460` (хексадекадно `0xCCCCCCCC`) говоре ти да елементи низа којима
приступаш нису иницијализовани. Ако не желиш да се на стандардном излазу
исписују неицијализовани елементи, то можеш решити условним наредбама - у овом
случају:

```c
#include <stdio.h>

int main(void)
{
    int o[10];
    o[0] = 5;
    o[1] = 4;
    o[2] = 5;
    o[3] = 4;
    o[4] = 5;
    int n = sizeof(o) / sizeof(int);
    for (int i = 0; i < n; i++)
        if (o[i] != 0xCCCCCCCC)
            printf("%d ", o[i]);
    return 0;
}
```
